\chapter{Database}\label{chap:database}

Dette kapitel vil omhandle valget af en løsningen, på at opnå persistens mellem kørsler af programmet.
Det ønskes naturligvis at programmet kan lagre sit data, udenfor RAM, for at kunne bruge det igen senere, og det var et fælles ønske fra gruppens side, at der blev brugt tid på at tilføje dette element til programmet.

\section{Persistensløsninger}

Der findes flere løsninger til denne problemstilling, der kan vælges en bestemt database ud fra de eksistrende databaser eller dataet kan gemmes på flade filer.

\subsection{Flade filer}
En simpel løsning på persistensproblemet ville være at gemme alt data på en flad fil ved programlukning, og læse filen igen ved programmets opstart.
Denne løsningen bliver dog hurtig upraktisk, da flade filer ikke har samme evne til at skalere til et større system, som egentlige databaser.

\subsection{Databaser}
Efter research, herunder rådgivning fra OOP lektor Rene Hansen, stod valget mellem to databaser: Entity Framework og SQLite.

\subsubsection*{Entity Framework}
Den første af de to, \ac{EF}, er en Object-Relational Mapping (ORM), til dotNet Frameworket.
Et ORM skaber et billede af objekterne i hukommelsen i databasen. 
Herunder var rådgivningen fra Rene Hansen, at anvende Code-First udvikling.
Med Code-First designes objekterne først, i form af modelklasser, hvorefter databasen og tabellerne i denne genereres ud fra sammenkoblingen mellem de forskellige modeller. Denne sammenkobling sker i såkaldte migrations, som opretter, ændrer og sletter tabeller, afhængigt af ændringerne i de benyttede modeller.
Fordelen ved denne løsning er, at mange tekniske valg træffes af programmet, så programmøren ikke behøver at have et kendskab til \ac{SQL} for at kunne benytte databasen og dermed persistens.
Dette gør \ac{EF} til en attraktiv løsning for grupper, der gerne vil hurtigt i gang med at programmere en løsning, uden først at sætte sig ind i databaseprogrammering.

\subsubsection*{SQLite}
Den anden kandidat er SQLite, som er et \ac{RDBMS}, hvilket betyder, at det benytter \ac{SQL} til de forskellige former for datahåndtering, såsom INSERT til at indsætte data, og SELECT til at hente data fra databasen.
SQLite er en letvægts embedded database, der er velegnet til mindre programmer, som har behov for lokal persistens.
At en database er embedded betyder, at den ikke kører i et separat program, men inkluderes som et bibliotek i programmet.
SQLite implementerer det meste af SQL-standarden, men udelader de dele, der af SQLite-udviklerne er bedømt til at være for tunge eller unødige til at have med.
Målet med SQLite er at bibeholde letvægten, da systemet også benyttes på mange mobile enheder, såsom Android.

Begge databaser blev implementeret under projektarbejdet, grundet komplikationer med første valget af database, Entity Framework. 


\section{Database Abstraction Layer}
Et \ac{DAL} bruges til at separere programmet fra databasen.
Dette gør det muligt at udskifte det underliggende persistenslag, samt at lave lag, der simulerer persistens, ved udelukkende at gemme data i hukommelsen, så længe programmet kører.
Man udstiller et interface til programmet, som så anvendes, og ikke en direkte forbindelse.
Hver tabel som findes i den database programmet skal anvende, skal have sin egen \ac{DAL}, som er logikken der forbinder til databasen.
Der findes fire basale operationer til en database, kaldt CRUD: Create, Read, Update, Delete. 
Hver af disse operationer skal DALet udstille, og yderligere metoder kan tilføjes efter behov.

\section{Den valgte løsning}

Efter anbefaling fra OOP lektor Rene Hansen, valgte gruppen at fokusere på \acl{EF} med Code-First, grundet manglende kendskab til \ac{SQL}.
Det blev yderligere bestemt, at der skulle designes et \ac{DAL}, med henblik på at øge muligheden for at teste systemet.

\subsection{Design af \ac{DAL}}

Der blev udviklet et generisk \ac{DAL}-interface, som hver af de konkrete \ac{DAL}-interfaces nedarver fra.
Interfacet definerer otte metoder, som beskrevet i \myref{tab:ourExtCrud}.

\begin{table}[h]
    \begin{tabular}{p{2cm}|p{13cm}}
    \textbf{Metode}   & \textbf{Forklaring}       \\ \hline
    \texttt{Create}   & Opretter et eller flere nye elementer i databasen.                                           \\ \hline
    \texttt{Update}   & Opdaterer et eller flere elementer i databasen.                                              \\ \hline
    \texttt{Delete}   & Fjerner et eller flere elementer fra databasen.                                              \\ \hline
    \texttt{GetAll}   & Findes i to udgaver, en som henter alle elementer, og en hvor der kan medsendes et prædikat. \\ \hline
    \texttt{GetOne}   & Henter et element i databasen, ud fra det angivne itemId.                                    \\ \hline
    \texttt{LoadData} & Findes i to udgaver, de henter de indre referencetype objekter til elementet eller elementerne givet. \\ \hline
    \end{tabular}
    \caption{Forklaring af hver metode i det generiske DAL interface.}
    \label{tab:ourExtCrud}
\end{table}

De konkrete interfaces defineres for hver modelklasse og implementeres i specifikke klasser, der snakker med et persistenslag.
For at gøre det lettere at udskifte \ac{DAL}-implementation, blev en statisk hjælpeklasse, \texttt{DalLocator}, oprettet, hvis opgave består i at returnere en implementation af et \ac{DAL}-interface. Hermed skal der kun foretages ændringer i en enkelt fil, hvis et nyt DAL tages i brug.
På \myref{img:Program_flow} kan man se hvordan \ac{DAL} indgår i programmets struktur.

\subsection{Første implementation --- \acl{EF}}\label{subsec:Pwoblem}

\acl{EF} blev implementeret for modellerne og systemet blev bygget herpå.
Under programmets udvikling stod det klart, at det ikke var helt problemfrit at benytte \ac{EF}.

Migrations kom i vejen for hinanden og gav konflikter, der krævede, at gruppens medlemmer regelmæssigt skulle slette hver tabel og kalde kommandoen \texttt{Update-Database}.
Denne kommando får \ac{EF} til at gennemløbe alle migrations og udføre handlingerne i disse.

Systemet reagerede også sporadisk, hvor det ét sted fungerede som det skulle, mens det fejlede lydløst, altså uden en fejlbesked, andre steder.
Dette til trods for, at de to områder var programmeret ens.

\subsection{Anden implementation --- SQLite}

Gruppen aftalte at forsøge en implementation af SQLite i stedet for.
Det var på dette tidspunkt, at det udviklede \acl{DAL} viste sin styrke, da hele persistenslaget kunne udskiftes uden konflikter i koden.

Den implementerede løsning er relativt simpel i sin konstruktion, især i forhold til \acl{EF}.
Dette blev gjort for at sikre, at det ikke ville tage mere end et par dage at implementere og teste.

SQLites enkeltbruger-design har dog også givet lidt problemer, idet databasen til tider angiver, at den er låst af en anden proces.
Disse problemer kan forårsages af flere ting, og virker til at opstå tilfældigt, så det er svært at forudse, hvor og hvornår det vil ske.

\subsection{Ekstra implementation --- Mock-data}

Som en backup--løsning, i tilfælde af, at SQLite pludseligt fejler, er en mock--implementation designet.
Denne implementation simulerer persistens, men gemmer kun i RAM mens programmet kører, og slettes derefter.
\fxnote{Jeg udvider dette afsnit, så snart jeg har verificeret, at det virker som det skal.}


%I forbindelse med programmets data var det nødvendigt at overveje, om programmet skulle have foruddefineret
%data, som ville blive nulstillet ved hvert programopstart, eller om dataene skulle gemmes mellem kørsler.
%
%Efter nogen overvejelse blev det bestemt, at der skulle benyttes et såkaldt persistenslag. Efter at have
%overvejet SQLite og \ac{EF} faldt valget på \ac{EF}, der er populært blandt C\#--udviklere, da det tillader en
%hurtig start på kodeprocessen.
%
%\ac{EF} er et såkaldt \ac{ORM} framework, der sammenkæder tabeller i en database med objekter i et program.
%Det kan benyttes på flere måder, der kort fortalt afhænger af, om man starter med en defineret database, eller
%en samling af klasser. Sidstnævnte mulighed kaldes for ``Code First'' og blev den valgte metode, da det tillod
%en -- for gruppen -- logisk arbejdsproces, hvori klassestrukturen blev opbygget, og databasen blev automatisk
%tilpasset denne.
%
%Der blev truffet afgørelse i gruppen om at benytte et såkaldt \ac{DAL} til at give programmet yderligere
%robusthed. Et \ac{DAL} er en samling af interfaces, samt implementationer af disse, som lægger sig mellem
%programmet og det valgte persistenslag. Hermed opnås mulighed for at udskifte persistenslag, eller sågar
%benytte flere forskellige i det samme program. Ligeledes bliver det muligt at have et lag specifikt til at
%teste med. I yderste konsekvens, hvis det skulle vise sig, af \ac{EF} fejlede, og der ikke kunne rettes op på
%det i tide, så ville det være muligt at skrive en såkaldt ``mock implementation'', hvilket ville give den
%først overvejede mulighed for at have data, som ikke gemmes i noget lager.
%
%Det er også værd at bemærke, at mange udviklere vælger at benytte \ac{EF} Code First under udviklingen, med en
%passende \ac{DAL}--implementation, for derefter, når programmet skal distribueres, at kode en implementation
%der benytter en database eller lignende, som de har fuld kontrol over. \ac{EF} har et højt abstraktionsniveau,
%hvilket simplificerer arbejdsprocessen, men fratager udvikleren en del kontrol.


%\section{Det ``gamle'' --- Bare i tilfælde af, at noget af det skal bruges.}
%
%For at kunne holde på data, imellem kørsler af programmet, skal der været en form for persistens. 
%Dette opnåes ved at lagere data. 
%
%Til lagering af data findes der flere måder, den primære overvejse er mellem en database og tekstfiler.
%Flade filer, eller såkaldte ``flat files'' på engelsk, er tekstfiler, som bruges til datalagring. 
%Flade filer er en meget simpel løsning, som vil være nemt at få i gang, men den skalerer ikke særligt godt. 
%%Fordelen ved flade filer er, at de er meget simple at håndtere, hvor databaser på den anden side er mere avanceret at håndtere og programmere. 
%%På den anden side var der databaser. Der var under dette valg ikke taget stilling til hvilken type database, som skulle bruges, men bare om der generelt skulle bruges database. 
%En database er et stykke software som opbevarer data, på en hensigtsmæssig måde. 
%Der findes en lang række af database management systemer (DBMS) hver med fordele og ulemper, mange af dem understøtter Structured Query Language (SQL) standarden.
%
%Med databaser kan der dog være flere muligheder for datahåndtering, og der er også løsninger til C\#, som skulle være til at overkomme at implementere.\citep{flatfiles} 
%Af den grund blev der valgt at bruge almindelig database fremfor flade filer. 
%
%Gruppen kiggede nærmere på SQLite og Entity Framework (Code-First). 
%SQLite er en serverløs, selvstændig, konfigurationsløs database. 
%Dette gør den meget simpel i anvendelse, samt ville resourceforbruget være meget lavt. 
%Entity Framework er en object-relational mapping (ORM) framework til .NET platformen. 
%Altså får hvert objekt, der ønskes lagret, en plads i databasen. 
%Med ``Entity Code First'' arbejdsmodellen, så laves klasser først, hvorefter Entity Framework håndterer integrationen med dens database.
%
%Gruppen adspurte vores underviser i Objet Orienteret Programmering, og han anbefalede Entity Framework (Code-First), til vores problemstilling. 
%Valget faldte derfor på Entity Framework, med Code-First mønsteret. 

%Valget af database kom til at stå mellem at bruge SQLite og Entity Framework. SQLite er et databasesystem, som har implementeret det meste af SQL standarderne.
%SQLite blev taget i betragtning, da det skulle være meget simpelt at implementere og bruge og, at det ligeledes er et populært valg til lokal database. 
%Fordelen ved SQLite er dens simpelhed og integration med C\#. 
%På den anden side er der det såkaldte Entity Framework, som er en Object Relational Mapper (ORM) for ADO.NET, hvilket vil sige, at den skaber objekter og entities alt efter databasetabellerne og skaber mekanismer for bl.a. CRUD (Create, Read, Update, Delete) opperationer. \citep{entity} 
%Den måde som Entity Framework regnes med at blive implementeret, er såkaldt ``Entity Code First'', hvilket, som navnet antyder, er at kodningen starter før opsætningen og programmeringen af selve databasen. Der er også mulighed for at lava databasen først, og så kode bagefter.
%Fordelen ved Entity Framework er, som nævnt før, muligheden for at kode først, og derefter lave databasen ud fra det eksisterende kode. 
%Valget faldt på Entity Framwork, da det skulle være simpelt at implementere. Vi var også blevet anbefalet at bruge Entity Framework af vores C\#-lærer.\fxnote{Skal der henvises til vores lærers anbefaling eller bare droppe det?}

%Sammen med Entity Framework, så gøres der brug af et såkaldt Data Abstraction Layer (DAL), hvilket virker som en adskillelse mellem selve koden og databasen, så koden stadig vil virke uden databasen. 
%Ved brug af et DAL, så er det også muligt at teste databasen, bl.a. læse og skrivemuligheder. 
