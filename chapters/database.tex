\chapter{Database}

I forbindelse med programmets data var det nødvendigt at overveje, om programmet skulle have foruddefineret
data, som ville blive nulstillet ved hvert programopstart, eller om dataene skulle gemmes mellem kørsler.

Efter nogen overvejelse blev det bestemt, at der skulle benyttes et såkaldt persistenslag. Efter at have
overvejet SQLite og \ac{EF} faldt valget på \ac{EF}, der er populært blandt C\#--udviklere, da det tillader en
hurtig start på kodeprocessen.

\ac{EF} er et såkaldt \ac{ORM} framework, der sammenkæder tabeller i en database med objekter i et program.
Det kan benyttes på flere måder, der kort fortalt afhænger af, om man starter med en defineret database, eller
en samling af klasser. Sidstnævnte mulighed kaldes for ``Code First'' og blev den valgte metode, da det tillod
en -- for gruppen -- logisk arbejdsproces, hvori klassestrukturen blev opbygget, og databasen blev automatisk
tilpasset denne.

Der blev truffet afgørelse i gruppen om at benytte et såkaldt \ac{DAL} til at give programmet yderligere
robusthed. Et \ac{DAL} er en samling af interfaces, samt implementationer af disse, som lægger sig mellem
programmet og det valgte persistenslag. Hermed opnås mulighed for at udskifte persistenslag, eller sågar
benytte flere forskellige i det samme program. Ligeledes bliver det muligt at have et lag specifikt til at
teste med. I yderste konsekvens, hvis det skulle vise sig, af \ac{EF} fejlede, og der ikke kunne rettes op på
det i tide, så ville det være muligt at skrive en såkaldt ``mock implementation'', hvilket ville give den
først overvejede mulighed for at have data, som ikke gemmes i noget lager.

Det er også værd at bemærke, at mange udviklere vælger at benytte \ac{EF} Code First under udviklingen, med en
passende \ac{DAL}--implementation, for derefter, når programmet skal distribueres, at kode en implementation
der benytter en database eller lignende, som de har fuld kontrol over. \ac{EF} har et højt abstraktionsniveau,
hvilket simplificerer arbejdsprocessen, men fratager udvikleren en del kontrol.




\section{Det ``gamle'' --- Bare i tilfælde af, at noget af det skal bruges.}

For at kunne holde på data, imellem kørsler af programmet, skal der været en form for persistens. 
Dette opnåes ved at lagere data. 

Til lagering af data findes der flere måder, den primære overvejse er mellem en database og tekstfiler.
Flade filer, eller såkaldte ``flat files'' på engelsk, er tekstfiler, som bruges til datalagring. 
Flade filer er en meget simpel løsning, som vil være nemt at få i gang, men den skalerer ikke særligt godt. 
%Fordelen ved flade filer er, at de er meget simple at håndtere, hvor databaser på den anden side er mere avanceret at håndtere og programmere. 
%På den anden side var der databaser. Der var under dette valg ikke taget stilling til hvilken type database, som skulle bruges, men bare om der generelt skulle bruges database. 
En database er et stykke software som opbevarer data, på en hensigtsmæssig måde. 
Der findes en lang række af database management systemer (DBMS) hver med fordele og ulemper, mange af dem understøtter Structured Query Language (SQL) standarden.

Med databaser kan der dog være flere muligheder for datahåndtering, og der er også løsninger til C\#, som skulle være til at overkomme at implementere.\citep{flatfiles} 
Af den grund blev der valgt at bruge almindelig database fremfor flade filer. 

Gruppen kiggede nærmere på SQLite og Entity Framework (Code-First). 
SQLite er en serverløs, selvstændig, konfigurationsløs database. 
Dette gør den meget simpel i anvendelse, samt ville resourceforbruget være meget lavt. 
Entity Framework er en object-relational mapping (ORM) framework til .NET platformen. 
Altså får hvert objekt, der ønskes lagret, en plads i databasen. 
Med ``Entity Code First'' arbejdsmodellen, så laves klasser først, hvorefter Entity Framework håndterer integrationen med dens database.

Gruppen adspurte vores underviser i Objet Orienteret Programmering, og han anbefalede Entity Framework (Code-First), til vores problemstilling. 
Valget faldte derfor på Entity Framework, med Code-First mønsteret. 

%Valget af database kom til at stå mellem at bruge SQLite og Entity Framework. SQLite er et databasesystem, som har implementeret det meste af SQL standarderne.
%SQLite blev taget i betragtning, da det skulle være meget simpelt at implementere og bruge og, at det ligeledes er et populært valg til lokal database. 
%Fordelen ved SQLite er dens simpelhed og integration med C\#. 
%På den anden side er der det såkaldte Entity Framework, som er en Object Relational Mapper (ORM) for ADO.NET, hvilket vil sige, at den skaber objekter og entities alt efter databasetabellerne og skaber mekanismer for bl.a. CRUD (Create, Read, Update, Delete) opperationer. \citep{entity} 
%Den måde som Entity Framework regnes med at blive implementeret, er såkaldt ``Entity Code First'', hvilket, som navnet antyder, er at kodningen starter før opsætningen og programmeringen af selve databasen. Der er også mulighed for at lava databasen først, og så kode bagefter.
%Fordelen ved Entity Framework er, som nævnt før, muligheden for at kode først, og derefter lave databasen ud fra det eksisterende kode. 
%Valget faldt på Entity Framwork, da det skulle være simpelt at implementere. Vi var også blevet anbefalet at bruge Entity Framework af vores C\#-lærer.\fxnote{Skal der henvises til vores lærers anbefaling eller bare droppe det?}

%Sammen med Entity Framework, så gøres der brug af et såkaldt Data Abstraction Layer (DAL), hvilket virker som en adskillelse mellem selve koden og databasen, så koden stadig vil virke uden databasen. 
%Ved brug af et DAL, så er det også muligt at teste databasen, bl.a. læse og skrivemuligheder. 
